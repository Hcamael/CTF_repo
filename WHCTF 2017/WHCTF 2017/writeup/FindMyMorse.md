### FindMyMorse

拆包分析发现app的入口点在libnative.so中，找到android_ main就可以找到程序的主逻辑。

发现程序在0x2154处对用户的操作进行了检测。

![](http://ovammr8jd.bkt.clouddn.com/whctf-2018-an.png)

这个地方的校验比较简单，很容易写出解密程序：

```c
 	unsigned char s[32]={
        0xA7, 0xD6, 0x61, 0xB5, 0x6E, 0xBB, 0xBA, 0xE3, 0xA9, 0xDD, 
        0xC4, 0x77, 0x6F, 0xEE, 0xEC, 0xFF, 0x62, 0xC3, 0xCF, 0xDA, 
        0x53, 0xCE, 0xFF, 0x71, 0x71, 0x14, 0xFF, 0xF2
      };
    char de[300]={0};
    for(int i=0;i!=224;i++)
    {
        int nowindex = (7*(i%4)) + (i/32);
        if((s[nowindex]&1))
        {
            de[i] = '-';
        }
        else
        {
            de[i] = '.';
        }
        int tmp = s[nowindex];
        s[nowindex]= (tmp>>1);        
    }
```

但是解出来这一堆绝对不是摩斯电码，根本没有办法分割字符：

```
--..--.--.--..--....---..-------.----.---.--.----.--.----.--------.-..-..-...-...-.--.------.-..-.--..-.--......-..--..-.------..--.---.-----.-..-.---..---...-.--.-----.-.------.----.-.----.--..-.----.-..--..-.----.-.-----.-
```

于是转变一下思路，可以想到有两种状态的东西还有二进制序列，序列的长度是224，可以是4，7，8为一组的字节流，于是都试了一遍，发现7个一组的时候可以解出flag.

```c
	char de2[60]={0};
    for(int i=0;i<32;i++)
    {
        int tmp = i*7;
        int tmp2 = 0;
        for(int j=0;j<7;j++)
        {
            if(de[tmp+j] == '-')
            {
                tmp2+=(1<<(6-j));
            }
            
        }
        de2[i]=tmp2;
    }
```

